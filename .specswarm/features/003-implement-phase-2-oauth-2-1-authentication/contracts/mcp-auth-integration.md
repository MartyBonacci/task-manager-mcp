# MCP Authentication Integration

**Feature**: 003 - OAuth 2.1 Authentication
**Created**: 2025-12-26
**MCP Specification**: 2025-06-18

---

## Overview

This document defines how OAuth 2.1 authentication integrates with the Model Context Protocol (MCP) for the Task Manager MCP Server. It specifies which MCP methods require authentication, how session state is transmitted, and error handling for authentication failures.

---

## Authentication Requirements by MCP Method

### Unauthenticated Methods

The following MCP methods DO NOT require authentication:

#### 1. `initialize`

**Purpose**: Protocol handshake and capability negotiation

**Request Example**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18",
    "capabilities": {},
    "clientInfo": {
      "name": "Claude",
      "version": "1.0.0"
    }
  }
}
```

**Response** (No auth required):
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "tools": {}
    },
    "serverInfo": {
      "name": "task-manager-mcp",
      "version": "2.0.0"
    }
  }
}
```

**Rationale**: Clients need to discover server capabilities before authenticating

---

#### 2. `tools/list`

**Purpose**: Discover available MCP tools

**Request Example**:
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/list"
}
```

**Response** (No auth required):
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "tools": [
      {
        "name": "task_create",
        "description": "Create a new task",
        "inputSchema": {...}
      },
      {
        "name": "task_list",
        "description": "List tasks with optional filters",
        "inputSchema": {...}
      }
    ]
  }
}
```

**Rationale**: Clients need to see available tools before authenticating (displays "Task Manager requires authentication" message to user)

---

### Authenticated Methods

The following MCP method REQUIRES authentication:

#### `tools/call`

**Purpose**: Execute any MCP tool operation

**Request Example** (Missing authentication):
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "tools/call",
  "params": {
    "name": "task_create",
    "arguments": {
      "title": "Review Q4 budget"
    }
  }
}
```

**Error Response** (401 Unauthorized):
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32001,
    "message": "Authentication required",
    "data": {
      "error": "authentication_required",
      "authorization_url": "http://localhost:8000/oauth/authorize",
      "instructions": "Click the authorization URL to sign in with Google"
    }
  }
}
```

**Authenticated Request**:
```http
POST / HTTP/1.1
Host: localhost:8000
Content-Type: application/json
MCP-Session-Id: 8N_0XZrqX3lRhFk9vFGZpA

{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "tools/call",
  "params": {
    "name": "task_create",
    "arguments": {
      "title": "Review Q4 budget"
    }
  }
}
```

**Success Response**:
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"id\": 42, \"title\": \"Review Q4 budget\", ...}"
      }
    ]
  }
}
```

**Rationale**: All task operations require user identity for data isolation

---

## Session Transmission

### HTTP Header

Authentication state is transmitted via custom HTTP header:

```
MCP-Session-Id: <session-id>
```

**Format**:
- Session ID: 43-character URL-safe base64 string
- Example: `8N_0XZrqX3lRhFk9vFGZpA`
- Generated by server during OAuth callback

**Client Behavior**:
1. Client receives `session_id` from `/oauth/callback`
2. Client stores `session_id` securely (platform-specific)
3. Client includes `MCP-Session-Id` header in all `tools/call` requests
4. Client handles 401 errors by re-authenticating

---

## Authentication Flow Diagram

```
┌─────────┐                                  ┌──────────┐
│ Client  │                                  │  Server  │
│ (Claude)│                                  │   MCP    │
└────┬────┘                                  └─────┬────┘
     │                                              │
     │  1. POST / {"method": "initialize"}          │
     ├─────────────────────────────────────────────>│
     │                                              │
     │  2. Response: Server capabilities            │
     │<─────────────────────────────────────────────┤
     │                                              │
     │  3. POST / {"method": "tools/list"}          │
     ├─────────────────────────────────────────────>│
     │                                              │
     │  4. Response: Available tools                │
     │<─────────────────────────────────────────────┤
     │                                              │
     │  5. POST / {"method": "tools/call"}          │
     │     (No MCP-Session-Id header)               │
     ├─────────────────────────────────────────────>│
     │                                              │
     │  6. ERROR 401: Authentication required       │
     │     {authorization_url: "/oauth/authorize"}  │
     │<─────────────────────────────────────────────┤
     │                                              │
     │  7. User clicks "Authorize"                  │
     │                                              │
     │  8. GET /oauth/authorize                     │
     ├─────────────────────────────────────────────>│
     │                                              │
     │  9. Response: {authorization_url: "..."}     │
     │<─────────────────────────────────────────────┤
     │                                              │
     │  10. Redirect to Google OAuth                │
     │                                              │
     │  [User signs in with Google]                 │
     │                                              │
     │  11. GET /oauth/callback?code=...&state=...  │
     ├─────────────────────────────────────────────>│
     │                                              │
     │  12. Response: {session_id: "8N_0..."}       │
     │<─────────────────────────────────────────────┤
     │                                              │
     │  13. POST / {"method": "tools/call"}         │
     │      MCP-Session-Id: 8N_0...                 │
     ├─────────────────────────────────────────────>│
     │                                              │
     │  14. Response: Task created successfully     │
     │<─────────────────────────────────────────────┤
     │                                              │
```

---

## Authentication Middleware Flow

### Request Processing

```python
@app.post("/")
async def mcp_handler(
    request: Request,
    db: Session = Depends(get_db),
    user_id: str = Depends(authenticate_mcp_request)
):
    """
    MCP protocol handler with authentication middleware.

    Middleware authenticates request and injects user_id into context.
    """
    body = await request.json()
    method = body.get("method")

    if method == "initialize":
        return handle_initialize()
    elif method == "tools/list":
        return handle_tools_list()
    elif method == "tools/call":
        # user_id injected by middleware (authenticated)
        params = body.get("params", {})
        params["user_id"] = user_id
        return await handle_tool_call(db, params)
    else:
        raise MethodNotFound(f"Unknown method: {method}")
```

### Middleware Implementation

```python
async def authenticate_mcp_request(
    request: Request,
    db: Session = Depends(get_db)
) -> Optional[str]:
    """
    Authenticate MCP request and return user_id.

    Returns:
        str: Authenticated user_id for tools/call
        None: For initialize and tools/list (no auth required)

    Raises:
        HTTPException(401): If authentication fails
    """
    body = await request.json()
    method = body.get("method")

    # Unauthenticated methods
    if method in ["initialize", "tools/list"]:
        return None

    # Authenticated methods
    if method == "tools/call":
        session_id = request.headers.get("MCP-Session-Id")

        if not session_id:
            raise HTTPException(
                status_code=401,
                detail={
                    "error": "authentication_required",
                    "message": "MCP-Session-Id header required for this method",
                    "authorization_url": "/oauth/authorize",
                    "instructions": "Click the authorization URL to sign in with Google"
                }
            )

        # Load session from database
        session = await get_session(db, session_id)
        if not session:
            raise HTTPException(
                status_code=401,
                detail={
                    "error": "invalid_session",
                    "message": "Session not found or expired",
                    "authorization_url": "/oauth/authorize"
                }
            )

        # Check token expiration
        if session.expires_at < datetime.now(timezone.utc):
            # Auto-refresh token
            session = await refresh_session_tokens(db, session)

        # Validate access token with Google
        access_token = decrypt_token(session.access_token)
        try:
            idinfo = id_token.verify_oauth2_token(
                access_token,
                google_requests.Request(),
                GOOGLE_CLIENT_ID
            )
        except Exception as e:
            raise HTTPException(
                status_code=401,
                detail={
                    "error": "token_validation_failed",
                    "message": "OAuth token is invalid or revoked",
                    "authorization_url": "/oauth/authorize"
                }
            )

        # Update session activity
        session.last_activity = datetime.now(timezone.utc)
        await db.commit()

        return session.user_id

    # Unknown method
    return None
```

---

## Error Responses

### MCP Error Codes

All authentication errors use MCP-compliant error codes:

| Error Code | Name | Description | HTTP Status |
|------------|------|-------------|-------------|
| -32001 | Server Error | Authentication required | 401 |
| -32001 | Server Error | Token expired/invalid | 401 |
| -32001 | Server Error | Access revoked | 403 |

**Note**: MCP spec doesn't define custom error codes for authentication, so we use `-32001` (Server Error) with descriptive `data` field.

### Error Response Format

```json
{
  "jsonrpc": "2.0",
  "id": <request-id>,
  "error": {
    "code": -32001,
    "message": "<user-friendly-message>",
    "data": {
      "error": "<machine-readable-code>",
      "message": "<detailed-message>",
      "authorization_url": "<re-auth-url>",
      "instructions": "<what-to-do>"
    }
  }
}
```

### Specific Error Scenarios

#### 1. Missing Session Header

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32001,
    "message": "Authentication required",
    "data": {
      "error": "authentication_required",
      "message": "MCP-Session-Id header required for this method",
      "authorization_url": "/oauth/authorize",
      "instructions": "Click the authorization URL to sign in with Google"
    }
  }
}
```

#### 2. Invalid Session

```json
{
  "jsonrpc": "2.0",
  "id": 6,
  "error": {
    "code": -32001,
    "message": "Invalid session",
    "data": {
      "error": "invalid_session",
      "message": "Session not found or expired",
      "authorization_url": "/oauth/authorize",
      "instructions": "Your session has expired. Please re-authorize."
    }
  }
}
```

#### 3. Token Expired (Auto-Refresh Success)

**No error** - Middleware automatically refreshes token and continues request processing.

#### 4. Token Expired (Refresh Failed)

```json
{
  "jsonrpc": "2.0",
  "id": 7,
  "error": {
    "code": -32001,
    "message": "Token refresh failed",
    "data": {
      "error": "token_expired",
      "message": "Your session has expired and could not be refreshed",
      "authorization_url": "/oauth/authorize",
      "instructions": "Please re-authorize to continue"
    }
  }
}
```

#### 5. Access Revoked

```json
{
  "jsonrpc": "2.0",
  "id": 8,
  "error": {
    "code": -32001,
    "message": "Access revoked",
    "data": {
      "error": "access_revoked",
      "message": "Task Manager access was revoked from your Google account",
      "authorization_url": "/oauth/authorize",
      "instructions": "Click the authorization URL to re-grant access"
    }
  }
}
```

---

## Client Implementation Guide

### Pseudocode

```python
class MCPClient:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session_id = None

    def initialize(self):
        """Initialize MCP connection (no auth)."""
        response = self.post("/", {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "initialize",
            "params": {...}
        })
        return response

    def list_tools(self):
        """List available tools (no auth)."""
        response = self.post("/", {
            "jsonrpc": "2.0",
            "id": 2,
            "method": "tools/list"
        })
        return response

    def call_tool(self, name: str, arguments: dict):
        """Call MCP tool (requires auth)."""
        if not self.session_id:
            self.authenticate()

        headers = {"MCP-Session-Id": self.session_id}
        response = self.post(
            "/",
            {
                "jsonrpc": "2.0",
                "id": 3,
                "method": "tools/call",
                "params": {"name": name, "arguments": arguments}
            },
            headers=headers
        )

        # Handle authentication errors
        if response.get("error", {}).get("data", {}).get("error") == "authentication_required":
            self.authenticate()
            return self.call_tool(name, arguments)  # Retry

        return response

    def authenticate(self):
        """Perform OAuth authentication flow."""
        # 1. Get authorization URL
        auth_response = self.get("/oauth/authorize")
        auth_url = auth_response["authorization_url"]

        # 2. Open browser for user to sign in
        webbrowser.open(auth_url)

        # 3. Wait for callback (implementation-specific)
        callback_url = wait_for_oauth_callback()

        # 4. Extract code and state from callback
        code = parse_callback_param(callback_url, "code")
        state = parse_callback_param(callback_url, "state")

        # 5. Exchange code for session
        callback_response = self.get(f"/oauth/callback?code={code}&state={state}")
        self.session_id = callback_response["session_id"]

        # 6. Store session ID securely
        self.save_session_id(self.session_id)
```

---

## Security Considerations

### Session Security

1. **Transmission**: Session ID transmitted only over HTTPS in production
2. **Storage**: Client stores session ID in secure platform-specific storage (keychain, credential manager)
3. **Expiration**: Sessions expire after 24 hours of inactivity
4. **Revocation**: Sessions deleted on logout or token revocation

### Token Security

1. **Encryption**: All OAuth tokens encrypted at rest (AES-256)
2. **Transmission**: Tokens never transmitted to client (only session ID)
3. **Validation**: Every request validates token with Google API
4. **Logging**: Tokens never logged or included in error messages

### CSRF Protection

1. **State Parameter**: Every OAuth flow includes cryptographically random state
2. **Validation**: State validated on callback
3. **Single-Use**: State deleted after validation

---

## Testing Guide

### Unit Tests

```python
@pytest.mark.asyncio
async def test_initialize_without_auth():
    """initialize method should work without authentication."""
    response = await client.post("/", {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {...}
    })
    assert response.status_code == 200
    assert "result" in response.json()

@pytest.mark.asyncio
async def test_tools_list_without_auth():
    """tools/list method should work without authentication."""
    response = await client.post("/", {
        "jsonrpc": "2.0",
        "id": 2,
        "method": "tools/list"
    })
    assert response.status_code == 200
    assert "result" in response.json()

@pytest.mark.asyncio
async def test_tools_call_requires_auth():
    """tools/call method should require authentication."""
    response = await client.post("/", {
        "jsonrpc": "2.0",
        "id": 3,
        "method": "tools/call",
        "params": {"name": "task_create", "arguments": {...}}
    })
    assert response.status_code == 401
    error = response.json()["error"]
    assert error["data"]["error"] == "authentication_required"
    assert "authorization_url" in error["data"]

@pytest.mark.asyncio
async def test_tools_call_with_valid_session(authenticated_client):
    """tools/call should work with valid session."""
    response = await authenticated_client.post(
        "/",
        {
            "jsonrpc": "2.0",
            "id": 4,
            "method": "tools/call",
            "params": {"name": "task_create", "arguments": {"title": "Test"}}
        },
        headers={"MCP-Session-Id": "valid-session-id"}
    )
    assert response.status_code == 200
    assert "result" in response.json()
```

---

## Integration with Existing Code

### Changes Required

#### `app/main.py`

**Before** (Phase 1):
```python
@app.post("/")
async def mcp_handler(request: Request, db: Session = Depends(get_db)):
    body = await request.json()
    method = body.get("method")

    if method == "tools/call":
        user_id = "dev-user"  # Hardcoded mock user
        params = body.get("params", {})
        params["user_id"] = user_id
        return await handle_tool_call(db, params)
```

**After** (Phase 2):
```python
@app.post("/")
async def mcp_handler(
    request: Request,
    db: Session = Depends(get_db),
    user_id: str = Depends(authenticate_mcp_request)  # Auth middleware
):
    body = await request.json()
    method = body.get("method")

    if method == "tools/call":
        # user_id injected by auth middleware
        params = body.get("params", {})
        params["user_id"] = user_id
        return await handle_tool_call(db, params)
```

---

## Changelog

### 2025-12-26
- Initial MCP authentication integration designed
- Authentication requirements by method defined
- Session transmission via MCP-Session-Id header
- Error response format aligned with MCP spec
- Client implementation guide created
- Testing strategy documented
